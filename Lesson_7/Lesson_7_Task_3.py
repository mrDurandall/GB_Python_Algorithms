# Массив размером 2m + 1, где m — натуральное число, заполнен случайным образом.
# Найдите в массиве медиану. Медианой называется элемент ряда, делящий его на две равные части:
# в одной находятся элементы, которые не меньше медианы, в другой — не больше медианы.

# Примечание: задачу можно решить без сортировки исходного массива.
# Но если это слишком сложно, используйте метод сортировки,
# который не рассматривался на уроках (сортировка слиянием также недопустима).


# Попробуем реализовать вариант без сортировки. Сам алгоритм поиска легко нашелся в интернете,
# так что остается только реализовать его програмно.


import random


def quick_search(data, k):
    """
    Алгоритм получения k-й порядковой статистики. Основан на алгоритме быстрой сортировки.
    :param data: список в котором нужно найти элемент.
    :param k: порядковый номер искомого элемента.
    """

    if k > len(data) - 1:
        print('Номер искомого элемента больше длины массива!')
        return None

    # Выберем номер опорного элемента и сохраним значение самого опорного элемента:
    pivot_idx = random.randint(0, len(data) - 1)
    pivot = data[pivot_idx]

    # Создадим три списка для хранения значений больше, равных и меньше опорного
    lesser = []
    larger = []
    pivots = []

    # Разделим исходный список по этим трём
    for el in data:
        if el == pivot:
            pivots.append(el)
        elif el < pivot:
            lesser.append(el)
        else:
            larger.append(el)

    # Если количество элементов меньше опорного равно номеру искомого, то опорный им и является.
    # Дополнительное условие отсекает вариант, когда в исходном массиве несколько одинаковых значений,
    # соответствующих искомому. В таком случае рекурсия зацикливалась и выпадала ошибка.
    if len(lesser) == k or len(lesser) == 0 and len(larger) == 0:
        return pivot
    # Если длина массива меньших числе больше искомого, то ищем его среди них.
    elif len(lesser) > k:
        return quick_search(lesser, k)
    # Если длина массива меньших числе меньше искомого, то ищем его среди оставшихся чисел,
    # предварительно уменьшив номер искомого на размер массива меньших.
    else:
        return quick_search(larger + pivots, k - len(lesser))


def median(data):
    """Функция поиска медианы. Фактически - поиск элемента
    по значению с номером len(data)//2."""
    # т.к. условия задачи предустмаривают, что в исходном массиве нечетное количество элементов,
    # то допустимо просто вызвать функцию quick_search в следующем виде:
    return quick_search(data, len(data) // 2)

# Тестирование функции поиска i-го по значению элемента списка:

# Создание массива
M = 4
array = [random.randint(0, 10) for _ in range(M * 2 + 1)]

# Выводим массив и его отсортированный вариант для тестирования:
print('Список:          ', array)
print('Отсортированный: ', sorted(array))

# Проверка на всех значениях i. Фактически результат должен совпадать с сортированным массивом.
for i in range(M * 2 + 1):
    print(quick_search(array, i), end=', ')
print('')

# Тестирование функции поиска медианы:
print('Список:          ', array)
print('Отсортированный: ', sorted(array))
print(median(array))

