# Подсчитать, сколько было выделено памяти под переменные в ранее разработанных программах в рамках первых трех уроков.
# Проанализировать результат и определить программы с наиболее эффективным использованием памяти.
# Примечание: По аналогии с эмпирической оценкой алгоритмов идеальным решением будет:
# ● выбрать хорошую задачу, которую имеет смысл оценивать по памяти;
# ● написать 3 варианта кода (один у вас уже есть);
# ● проанализировать 3 варианта и выбрать оптимальный;
# ● результаты анализа (количество занятой памяти в вашей среде разработки) вставить в виде комментариев
# в файл с кодом. Не забудьте указать версию и разрядность вашей ОС и интерпретатора Python;
# ● написать общий вывод: какой из трёх вариантов лучше и почему.

# Версия ОС: Microsoft Windows [Version 10.0.19041.928]
# Версия интерпретатора: Python 3.9.0 (tags/v3.9.0:9cf6752, Oct  5 2020, 15:34:40) [MSC v.1927 64 bit (AMD64)] on win32

# В качестве Задачи для исследования возьмем задание номер 8 к уроку 2:
# Посчитать, сколько раз встречается определенная цифра в введенной последовательности чисел.
# Количество вводимых чисел и цифра, которую необходимо посчитать, задаются вводом с клавиатуры.
#
# Для упрощения исследования, возможно внесение некоторых изменений в изначальную формулировку задачи.

# Вариант 1 - Использованный при решении задачи изначально. С использованием рекурсии.

# Сразу импортируем sys для подсчета использованной памяти и randint для использования при тестировании
import sys
from random import randint


def printtotalsize(*objects):
    """
    Функция для подсчета памяти, используемой объектами, переданными в качестве аргументов.
    Получает список объектов, выводит содержимое каждого, его тип и занимаемый объем памяти.
    Если объект - список или кортеж, ркурсивно вызывает сама себя для содержимого данного объекта.
    """
    total_size = 0
    for obj in objects:
        spam = sys.getsizeof(obj)
        total_size += spam
        print(f'{obj} : {type(obj)} : {spam:>10}')
        if type(obj) == list or type(obj) == tuple:
            printtotalsize(*obj)
        if type(obj) == dict:
            printtotalsize(*(list(obj.keys()) + list(obj.values())))
    print(f'Суммарный объем использованной памяти: {total_size}')


def counter(number, n, c):
    printtotalsize(number, n, c)
    if number // 10 == 0:
        if number == n:
            return c + 1
        else:
            return c
    else:
        if number % 10 == n:
            return counter(number // 10, n, c + 1)
        else:
            return counter(number // 10, n, c)

# Для тестирования жестко зададим колчиество чисел и искомое число
# total = int(input('Ведите количество чисел: '))
total = 100
# n = int(input('Ведите искомую цифру: '))
n = 5
c = 0
for i in range(total):

    # number = int(input(f'Ведите {i+1}-е число: '))
    number = randint(1, 500)
    c = counter(number, n, c)
print(f'В введенной последовательности чисел цифра {n} встречается {c} раз.')

# Для получения списка используемых объектов применим print(locals())
# {... 'total': 100, 'n': 5, 'c': 21, 'i': 99, 'number': 19}

# Измерим память, используемую данными переменными:
# printtotalsize(total, n, c, i, number)
# Результат подсчетов:

# 100 : <class 'int'> :         28
# 5 : <class 'int'> :         28
# 25 : <class 'int'> :         28
# 99 : <class 'int'> :         28
# 449 : <class 'int'> :         28
# Суммарный объем использованной памяти: 140

# Также необходимо учесть память, используемую внутри рекурсивной функции.
# Проверим, какие перменные создаются в функции при каждом проходе с помощью print(locals()):
# {'number': 160, 'n': 5, 'c': 0}
# Встроим в тело функции строчку printtotalsize(number, n, c) и подсчитаем необходимый объем памяти

# 6 : <class 'int'> :         28
# 5 : <class 'int'> :         28
# 16 : <class 'int'> :         28
# Суммарный объем использованной памяти: 84

# Это данные для одного прохода функции. Однако, учитывая, что функция рекурсивная, этот объем будет зависеть
# от глубины рекурсии. В нашем примере максимальная глубина не превышает 3, т.к. вводимые числа ограничены 3 знаками.
# Значит расход памяти внутри функции не будет превышать 84 * 3 = 252.
# Однако при вводе более длинных чисел он будет увеличиватья.

# Таким образом полный расход памяти при данном решении задачи будет 140 + 84 * N, где N зависит от вводимых чисел.


# 2й и 3й варианты решения смотри в файлах Lesson_6_var_2.py и Lesson_6_var_3.py

