# Написать два алгоритма нахождения i-го по счёту простого числа.
# Функция нахождения простого числа должна принимать на вход натуральное
# и возвращать соответствующее простое число. Проанализировать скорость и сложность алгоритмов.
#
# Первый — с помощью алгоритма «Решето Эратосфена».
# Примечание. Алгоритм «Решето Эратосфена» разбирался на одном из прошлых уроков.
# Используйте этот код и попробуйте его улучшить/оптимизировать под задачу.
#
# Второй — без использования «Решета Эратосфена».
# Примечание. Вспомните классический способ проверки числа на простоту.


import timeit

# Вариант с "Решетом Эратосфена":

def sieve(n):
    """
    Функция поиска n-го простого числа через решето Эратосфена
    Сперва создает список, содержащий все простые числа в промежутке от 2 до 100000,
    и возвращает значение элемента с номером n+1.
    """
    HOLE = 0
    num = 10000
    sieve = [i for i in range(num)]
    sieve[1] = HOLE

    for i in range(2, num):
        if sieve[i] != HOLE:
            j = i + i
            while j < num:
                sieve[j] = HOLE
                j += i
    primes = [item for item in sieve if item != HOLE]
    return primes[n - 1]

# В данной функции имеется цикл с вложенным в него циклом. Однако циклы выполняется не всегда,
# и с ростом числа количество их выполнения снижается. Поиск в интернете утверждает,
# что порядок роста для алгоритма решета Эратосфена O(n log log n).
# Однако в данном случае данный алгорит выполняется в полном объеме для каждого выполнения функции.
# Так что фактический порядок роста для всей функции является O(1).
# Проверим фактическое время выполнения функции.


print(timeit.timeit('sieve(10)', number=1000, globals=globals()))
print(timeit.timeit('sieve(100)', number=1000, globals=globals()))
print(timeit.timeit('sieve(1000)', number=1000, globals=globals()))

# Полученные результаты:
# 3.3134478
# 3.2305166
# 3.2307449

# Видим, что функция выполняется за одинаковое время, вне зависимости от тестового числа.
# Причем данное время является достаточно значительным. Если сравнивать со вторым вариантом (без решета),
# Время выполнения на малых значениях тестового числа существенно проигрывает, а на больших выигрывает.

# Функция расходует дополнительную память на хранение списка (в данной реализации получается даже 2 списка).
# Также она имеет ограничение по номеру искомого простого числа. При увеличении границы числа в функции,
# время ее выполнения увеличится в соответсвии со сложностью алгоритма решета Эратосфена.

# В данной реализации сразу бросается в глаза главная проблема - мы каждый раз строим один и тот же список.
# Простейшим решением в данном случае будет построить список единожды, сохранить в памяти
# и просто обращаться к нему, ища соответствующий элемент.
# Это позволит изначально потратить большое количество времени для создания списка с числами в большом диапазоне,
# а затем просто искать нужный элемент в готовом списке.


# Вариант без "Решета эратосфена":

def prime_number(n):
    '''
    Функция поиска n-го простого числа. с = счетчик простых чисел.
    По-умолчанию задано первое простое число - 2.
    Если надо найти простое число под номером больше одного, то производится последовательный перебор всех чисел,
    с проверкой каждого на "простоту". Если находится очередное простое число, то счетчик увеличивается на 1,
    а переменная текущего простого числа обновляется. Как только счетчик доходит до заданного числа,
    выполнение перебора завершается и функция возвращает текущее простое число.
    '''
    c = 1
    current_prime_number = 2
    number = 3
    while c < n:
        for divider in range(2, number):
            if number % divider == 0:
                break
        else:
            c += 1
            current_prime_number = number
        number += 1
    return current_prime_number

# Проанализируем получившуюся функцию.
# Наличие цикла в цикле, выполняющих полный последовательный перебор чисел, намекает на порядок роста O(n**2)
# Однако алгоритм не требует использования дополнительной памяти.
# Проверим это анализом через timeit

# print(timeit.timeit('prime_number(10)', number=1000, globals=globals()))
# print(timeit.timeit('prime_number(100)', number=1000, globals=globals()))
# print(timeit.timeit('prime_number(1000)', number=1000, globals=globals()))


# Полученные результаты:
# 0.013181599999999995
# 1.3443431000000001
# 218.9221413

# Как и предполагалось - увеличение тестового числа на 1 порядок,
# вызывает увеличение тестового времени на 2 порядка.
# При малых значениях тестового числа эфективность данного алгоритма выше чем у решета Эратосфена.
# Однако на больших числах он проигрывает даже варианту, когда решето строится при каждом выполнении функции.